<!DOCTYPE html> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#03A9F4 name=theme-color> <base href=/ > <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" rel=stylesheet> <link href=normalize.css rel=stylesheet> <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest> <link href=favicon.png rel=icon type=image/png> <style>a.svelte-8k7mgw{text-decoration:none;font-weight:700}a.svelte-8k7mgw:hover{text-decoration:underline}header.svelte-8k7mgw{background:#03a9f4;color:#fff;font-size:1.25rem;margin-bottom:2rem}header.svelte-8k7mgw div{align-items:center;display:flex;height:100%}div.svelte-1og7a9{margin:0 auto;padding:0 1rem;max-width:50rem}h1.svelte-cy6ghe{margin:0;margin-bottom:.25rem}.byline.svelte-cy6ghe{color:#888}.post-image.svelte-cy6ghe{background:#eee;display:block;width:100%}.title.svelte-cy6ghe{margin:2rem 0}</style> <link href=/client/1f48b0828407c44f3c70/main.js rel=preload as=script><link href=/client/1f48b0828407c44f3c70/blog_$slug.0.js rel=preload as=script></head> <body> <div id=root> <main> <header class=svelte-8k7mgw> <div class=svelte-1og7a9> <h1> <a href=/ class=svelte-8k7mgw>Sapper Blog</a> </h1> </div> </header> <article> <div class=svelte-1og7a9> <div class="svelte-cy6ghe title"> <h1 class=svelte-cy6ghe>Pages</h1> <div class="svelte-cy6ghe byline">by Matt Crouch</div> </div> <img alt="" class="svelte-cy6ghe post-image" src=/images/pages.png> <p>Pages are specific <a href=/blog/what-is-svelte>Svelte</a> components that define a page that can be linked and navigated to.</p> <p>All pages live inside the <code>/routes</code> directory. The location of that component determines the URL used to access it. For example, a page component stored inside <code>/routes/about/bio.svelte</code> can be accessed by visiting <code>/about/bio</code>.</p> <p>Naming a page component <code>index.svelte</code> will work similar to an <code>index.html</code> would anywhere else. To have a page at <code>/blog</code> it can either be <code>/routes/blog.svelte</code> or <code>/routes/blog/index.svelte</code>.</p> <h2 id=special-features>Special features</h2> <h3 id=server-rendering>Server rendering</h3> <p>When a user first lands on a URL for a page, the server will supply the full HTML rendered version of that page. That will then go and download the JavaScript that powers all the interactivity on that page and silently update (or "hydrate") the application later on.</p> <p>This ensures the user gets the page's content as quickly as possible and allows other visitors such as web crawlers and bots to digest the information a lot easier.</p> <h3 id=data-preloading>Data preloading</h3> <p>There needs to be some kind of mechanism for Sapper to know exactly what data a page needs to download in order to render it. Thankfully that is all sorted through a special <code>preload</code> function.</p> <pre><code class=language-html>&lt;script context="module">
  // Fetch blog posts and pre-load their contents
  export function preload({ params, query }) {
    return this.fetch("blog.json")
      .then(r => r.json())
      .then(posts => {
        return { posts };
      });
  }
&lt;/script>
&lt;script>
  // Export custom attributes for component
  export let posts;
&lt;/script></code></pre> <p>The <code>context</code> attribute on the script block tells Sapper that the contents is special. The <code>preload</code> function itself is provided with some of the information about the page being loaded, including and URL parameters that were supplied.</p> <p>This then returns a promise that describes the steps needed to go and get the data and what to do with it. The final returned data from that promise then goes and fills out a variable in the regular <code>&lt;script></code> block.</p> <p>When the promise resolves, Sapper knows the page's data is ready to render and starts pumping out the HTML to return in the request. As a result, a promise that is very slow to resolve can end up damaging the response time of the site rather than helping it. Make sure only the critical information about the page goes in there.</p> <h3 id=head-updates><code>&lt;head></code> updates</h3> <p>If needed, a page component can also update the contents within the <code>&lt;head></code> of the page through a special <code>&lt;svelte:head></code> tag.</p> <pre><code class=language-html>&lt;svelte:head>
  &lt;title>Sapper Blog&lt;/title>
&lt;/svelte:head></code></pre> <p>When Sapper encounters this, it injects it in to the defined part of the <code>template.html</code> file.</p> <p>While this is most commonly used to update the title of the window for each page, it can also add in more features by including extra HTML. For example, if there's a third-party widget that needs some extra JavaScript to run, this is a great place to put it. This makes sure it only ever gets requested on the page that actually uses it.</p> </div> </article> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{author:{name:"Matt Crouch",image:"\u002Fimages\u002Fmatt-crouch.jpg"},image:"\u002Fimages\u002Fpages.png",title:"Pages",slug:"pages",html:"\u003Cp\u003EPages are specific \u003Ca href=\"\u002Fblog\u002Fwhat-is-svelte\"\u003ESvelte\u003C\u002Fa\u003E components that define a page that can be linked and navigated to.\u003C\u002Fp\u003E\n\u003Cp\u003EAll pages live inside the \u003Ccode\u003E\u002Froutes\u003C\u002Fcode\u003E directory. The location of that component determines the URL used to access it. For example, a page component stored inside \u003Ccode\u003E\u002Froutes\u002Fabout\u002Fbio.svelte\u003C\u002Fcode\u003E can be accessed by visiting \u003Ccode\u003E\u002Fabout\u002Fbio\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003ENaming a page component \u003Ccode\u003Eindex.svelte\u003C\u002Fcode\u003E will work similar to an \u003Ccode\u003Eindex.html\u003C\u002Fcode\u003E would anywhere else. To have a page at \u003Ccode\u003E\u002Fblog\u003C\u002Fcode\u003E it can either be \u003Ccode\u003E\u002Froutes\u002Fblog.svelte\u003C\u002Fcode\u003E or \u003Ccode\u003E\u002Froutes\u002Fblog\u002Findex.svelte\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Ch2 id=\"special-features\"\u003ESpecial features\u003C\u002Fh2\u003E\n\u003Ch3 id=\"server-rendering\"\u003EServer rendering\u003C\u002Fh3\u003E\n\u003Cp\u003EWhen a user first lands on a URL for a page, the server will supply the full HTML rendered version of that page. That will then go and download the JavaScript that powers all the interactivity on that page and silently update (or &quot;hydrate&quot;) the application later on.\u003C\u002Fp\u003E\n\u003Cp\u003EThis ensures the user gets the page&#39;s content as quickly as possible and allows other visitors such as web crawlers and bots to digest the information a lot easier.\u003C\u002Fp\u003E\n\u003Ch3 id=\"data-preloading\"\u003EData preloading\u003C\u002Fh3\u003E\n\u003Cp\u003EThere needs to be some kind of mechanism for Sapper to know exactly what data a page needs to download in order to render it. Thankfully that is all sorted through a special \u003Ccode\u003Epreload\u003C\u002Fcode\u003E function.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E&lt;script context=&quot;module&quot;&gt;\n  \u002F\u002F Fetch blog posts and pre-load their contents\n  export function preload({ params, query }) {\n    return this.fetch(&quot;blog.json&quot;)\n      .then(r =&gt; r.json())\n      .then(posts =&gt; {\n        return { posts };\n      });\n  }\n&lt;\u002Fscript&gt;\n&lt;script&gt;\n  \u002F\u002F Export custom attributes for component\n  export let posts;\n&lt;\u002Fscript&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe \u003Ccode\u003Econtext\u003C\u002Fcode\u003E attribute on the script block tells Sapper that the contents is special. The \u003Ccode\u003Epreload\u003C\u002Fcode\u003E function itself is provided with some of the information about the page being loaded, including and URL parameters that were supplied.\u003C\u002Fp\u003E\n\u003Cp\u003EThis then returns a promise that describes the steps needed to go and get the data and what to do with it. The final returned data from that promise then goes and fills out a variable in the regular \u003Ccode\u003E&lt;script&gt;\u003C\u002Fcode\u003E block.\u003C\u002Fp\u003E\n\u003Cp\u003EWhen the promise resolves, Sapper knows the page&#39;s data is ready to render and starts pumping out the HTML to return in the request. As a result, a promise that is very slow to resolve can end up damaging the response time of the site rather than helping it. Make sure only the critical information about the page goes in there.\u003C\u002Fp\u003E\n\u003Ch3 id=\"head-updates\"\u003E\u003Ccode\u003E&lt;head&gt;\u003C\u002Fcode\u003E updates\u003C\u002Fh3\u003E\n\u003Cp\u003EIf needed, a page component can also update the contents within the \u003Ccode\u003E&lt;head&gt;\u003C\u002Fcode\u003E of the page through a special \u003Ccode\u003E&lt;svelte:head&gt;\u003C\u002Fcode\u003E tag.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E&lt;svelte:head&gt;\n  &lt;title&gt;Sapper Blog&lt;\u002Ftitle&gt;\n&lt;\u002Fsvelte:head&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EWhen Sapper encounters this, it injects it in to the defined part of the \u003Ccode\u003Etemplate.html\u003C\u002Fcode\u003E file.\u003C\u002Fp\u003E\n\u003Cp\u003EWhile this is most commonly used to update the title of the window for each page, it can also add in more features by including extra HTML. For example, if there&#39;s a third-party widget that needs some extra JavaScript to run, this is a great place to put it. This makes sure it only ever gets requested on the page that actually uses it.\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');</script><script src=/client/1f48b0828407c44f3c70/main.js></script> 