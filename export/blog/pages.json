{"author":{"name":"Matt Crouch","image":"/images/matt-crouch.jpg"},"image":"/images/pages.png","title":"Pages","slug":"pages","html":"<p>Pages are specific <a href=\"/blog/what-is-svelte\">Svelte</a> components that define a page that can be linked and navigated to.</p>\n<p>All pages live inside the <code>/routes</code> directory. The location of that component determines the URL used to access it. For example, a page component stored inside <code>/routes/about/bio.svelte</code> can be accessed by visiting <code>/about/bio</code>.</p>\n<p>Naming a page component <code>index.svelte</code> will work similar to an <code>index.html</code> would anywhere else. To have a page at <code>/blog</code> it can either be <code>/routes/blog.svelte</code> or <code>/routes/blog/index.svelte</code>.</p>\n<h2 id=\"special-features\">Special features</h2>\n<h3 id=\"server-rendering\">Server rendering</h3>\n<p>When a user first lands on a URL for a page, the server will supply the full HTML rendered version of that page. That will then go and download the JavaScript that powers all the interactivity on that page and silently update (or &quot;hydrate&quot;) the application later on.</p>\n<p>This ensures the user gets the page&#39;s content as quickly as possible and allows other visitors such as web crawlers and bots to digest the information a lot easier.</p>\n<h3 id=\"data-preloading\">Data preloading</h3>\n<p>There needs to be some kind of mechanism for Sapper to know exactly what data a page needs to download in order to render it. Thankfully that is all sorted through a special <code>preload</code> function.</p>\n<pre><code class=\"language-html\">&lt;script context=&quot;module&quot;&gt;\n  // Fetch blog posts and pre-load their contents\n  export function preload({ params, query }) {\n    return this.fetch(&quot;blog.json&quot;)\n      .then(r =&gt; r.json())\n      .then(posts =&gt; {\n        return { posts };\n      });\n  }\n&lt;/script&gt;\n&lt;script&gt;\n  // Export custom attributes for component\n  export let posts;\n&lt;/script&gt;</code></pre>\n<p>The <code>context</code> attribute on the script block tells Sapper that the contents is special. The <code>preload</code> function itself is provided with some of the information about the page being loaded, including and URL parameters that were supplied.</p>\n<p>This then returns a promise that describes the steps needed to go and get the data and what to do with it. The final returned data from that promise then goes and fills out a variable in the regular <code>&lt;script&gt;</code> block.</p>\n<p>When the promise resolves, Sapper knows the page&#39;s data is ready to render and starts pumping out the HTML to return in the request. As a result, a promise that is very slow to resolve can end up damaging the response time of the site rather than helping it. Make sure only the critical information about the page goes in there.</p>\n<h3 id=\"head-updates\"><code>&lt;head&gt;</code> updates</h3>\n<p>If needed, a page component can also update the contents within the <code>&lt;head&gt;</code> of the page through a special <code>&lt;svelte:head&gt;</code> tag.</p>\n<pre><code class=\"language-html\">&lt;svelte:head&gt;\n  &lt;title&gt;Sapper Blog&lt;/title&gt;\n&lt;/svelte:head&gt;</code></pre>\n<p>When Sapper encounters this, it injects it in to the defined part of the <code>template.html</code> file.</p>\n<p>While this is most commonly used to update the title of the window for each page, it can also add in more features by including extra HTML. For example, if there&#39;s a third-party widget that needs some extra JavaScript to run, this is a great place to put it. This makes sure it only ever gets requested on the page that actually uses it.</p>\n"}