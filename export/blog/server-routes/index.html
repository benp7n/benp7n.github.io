<!DOCTYPE html> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#03A9F4 name=theme-color> <base href=/ > <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" rel=stylesheet> <link href=normalize.css rel=stylesheet> <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest> <link href=favicon.png rel=icon type=image/png> <style>a.svelte-8k7mgw{text-decoration:none;font-weight:700}a.svelte-8k7mgw:hover{text-decoration:underline}header.svelte-8k7mgw{background:#03a9f4;color:#fff;font-size:1.25rem;margin-bottom:2rem}header.svelte-8k7mgw div{align-items:center;display:flex;height:100%}div.svelte-1og7a9{margin:0 auto;padding:0 1rem;max-width:50rem}h1.svelte-cy6ghe{margin:0;margin-bottom:.25rem}.byline.svelte-cy6ghe{color:#888}.post-image.svelte-cy6ghe{background:#eee;display:block;width:100%}.title.svelte-cy6ghe{margin:2rem 0}</style> <link href=/client/1f48b0828407c44f3c70/main.js rel=preload as=script><link href=/client/1f48b0828407c44f3c70/blog_$slug.0.js rel=preload as=script></head> <body> <div id=root> <main> <header class=svelte-8k7mgw> <div class=svelte-1og7a9> <h1> <a class=svelte-8k7mgw href=/ >Sapper Blog</a> </h1> </div> </header> <article> <div class=svelte-1og7a9> <div class="svelte-cy6ghe title"> <h1 class=svelte-cy6ghe>Server routes</h1> <div class="svelte-cy6ghe byline">by Matt Crouch</div> </div> <img alt="" class="svelte-cy6ghe post-image" src=/images/server-routes.png> <p>Sapper can manage the server side as well as the client side. While pre-rendering is all handled through middleware elsewhere, Sapper can consume other <code>.js</code> files to use them as endpoints for data.</p> <p>For some projects, there may be a need to consume data through a means other than HTML. For example, a blog might have a JSON endpoint or an RSS feed to generate. These server routes are a great place to create those.</p> <pre><code class=language-js>export function get(req, res) {
  const { slug } = req.params;

  if (lookup.has(slug)) {
    res.writeHead(200, {
      "Content-Type": "application/json"
    });

    res.end(lookup.get(slug));
  } else {
    res.writeHead(404, {
      "Content-Type": "application/json"
    });

    res.end(
      JSON.stringify({
        message: `Not found`
      })
    );
  }
}</code></pre> <p>Each <code>.js</code> file can export a function that corresponds to a HTTP method. The corresponding function is fired when a request comes in through that method.</p> <p>In the above example, we are checking if we have a blog post on file with that defined <code>slug</code> value. If we do, return it with a <code>200</code> response. If not, send a <code>404</code> instead.</p> <p>The data that powers these screens can come from anywhere - either consuming some other API on another service or by importing another local dataset. It's entirely up to us as developers to work out what's best for the project.</p> <p>Of course, there is no hard requirement to use server routes <em>at all</em>. If they are not useful, they can just be left off.</p> </div> </article> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{author:{name:"Matt Crouch",image:"\u002Fimages\u002Fmatt-crouch.jpg"},image:"\u002Fimages\u002Fserver-routes.png",title:"Server routes",slug:"server-routes",html:"\u003Cp\u003ESapper can manage the server side as well as the client side. While pre-rendering is all handled through middleware elsewhere, Sapper can consume other \u003Ccode\u003E.js\u003C\u002Fcode\u003E files to use them as endpoints for data.\u003C\u002Fp\u003E\n\u003Cp\u003EFor some projects, there may be a need to consume data through a means other than HTML. For example, a blog might have a JSON endpoint or an RSS feed to generate. These server routes are a great place to create those.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Eexport function get(req, res) {\n  const { slug } = req.params;\n\n  if (lookup.has(slug)) {\n    res.writeHead(200, {\n      &quot;Content-Type&quot;: &quot;application\u002Fjson&quot;\n    });\n\n    res.end(lookup.get(slug));\n  } else {\n    res.writeHead(404, {\n      &quot;Content-Type&quot;: &quot;application\u002Fjson&quot;\n    });\n\n    res.end(\n      JSON.stringify({\n        message: `Not found`\n      })\n    );\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EEach \u003Ccode\u003E.js\u003C\u002Fcode\u003E file can export a function that corresponds to a HTTP method. The corresponding function is fired when a request comes in through that method.\u003C\u002Fp\u003E\n\u003Cp\u003EIn the above example, we are checking if we have a blog post on file with that defined \u003Ccode\u003Eslug\u003C\u002Fcode\u003E value. If we do, return it with a \u003Ccode\u003E200\u003C\u002Fcode\u003E response. If not, send a \u003Ccode\u003E404\u003C\u002Fcode\u003E instead.\u003C\u002Fp\u003E\n\u003Cp\u003EThe data that powers these screens can come from anywhere - either consuming some other API on another service or by importing another local dataset. It&#39;s entirely up to us as developers to work out what&#39;s best for the project.\u003C\u002Fp\u003E\n\u003Cp\u003EOf course, there is no hard requirement to use server routes \u003Cem\u003Eat all\u003C\u002Fem\u003E. If they are not useful, they can just be left off.\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');</script><script src=/client/1f48b0828407c44f3c70/main.js></script> 